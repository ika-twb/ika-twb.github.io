<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-11-19 Sat 03:21 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Learning Perl(持续更新)</title>
<meta name="author" content="Ilghar Kus" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<style type="text/css">html {max-width: 70ch;padding: 3em 1em;margin: auto;line-height: 1.75;font-size: 1.25em;} a:link{color:black;} a:visited{color:#565656;} .backlink{position: fixed; top: 70;left: 50px;}</style><p class="backlink"><a href="/sitemap.html">Sitemap</a></p>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Learning Perl(持续更新)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org02f413c">总述：</a></li>
<li><a href="#org52b4d61">CH.1 Introduction</a></li>
<li><a href="#org8a93462">CH.2 Scalar Data</a>
<ul>
<li><a href="#orgaf21db0">Numbers</a>
<ul>
<li><a href="#orga71ca40">Decimal Numbers</a></li>
<li><a href="#org03a6f42">Nondecimal Integer</a></li>
<li><a href="#org98da00b">Numeric Operators</a></li>
</ul>
</li>
<li><a href="#orgfa581f9">Strings</a>
<ul>
<li><a href="#org342edf8">Single and Double Quoted Strings.</a></li>
<li><a href="#orgf5e7087">String Operators</a></li>
<li><a href="#org1bf04d9">Automatic Conversion Between Numbers and Strings</a></li>
</ul>
</li>
<li><a href="#org45f179f">Perl's Built-in Warnings</a></li>
<li><a href="#org38f9f7f">Scalar Variables</a></li>
<li><a href="#org4ca5b4b">Scalar Assignment</a></li>
<li><a href="#org26e754e">Output with print</a></li>
<li><a href="#org158b15f">Interpolation of Scalar Variables into Strings</a></li>
<li><a href="#org0ec277c">Operator Precedence and Associativity</a></li>
<li><a href="#org43b6e67">Comparison Operators</a></li>
<li><a href="#orgd0b64e1">The if Control Structure</a></li>
<li><a href="#orgb6f4246">Getting User Input</a></li>
<li><a href="#orgfbb72e1">The chomp Operator</a></li>
<li><a href="#org3c93488">The while Control Structure</a></li>
<li><a href="#orgd627683">The undel Value</a></li>
<li><a href="#org7cc8a25">The defined Function</a></li>
</ul>
</li>
<li><a href="#org280b32c">CH.3 List and Arrays</a>
<ul>
<li><a href="#org7bdb91a">List</a></li>
<li><a href="#orgd85d374">调用数列中的元素</a></li>
<li><a href="#orgbf864da">Special Array Indices</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org02f413c" class="outline-2">
<h2 id="org02f413c">总述：</h2>
<div class="outline-text-2" id="text-org02f413c">
<p>
这篇文章是我在阅读 <i>Learning Perl</i> (<i>Randal Schwartz, Tom Phoenix, brain d foy, 2008, O'Reilly Media</i> <code>978-0-596-52010-6</code>)(又称小骆驼书) 时做的笔记。
</p>

<p>
当然通过阅读这些笔记可能使你比起阅读原书更加快速的上手Perl，但是如果你有足够的时间我会推荐去阅读原书来形成比较流畅而且牢固的知识体系，而且我可能会在这篇笔记中填入一些自己先入为主的观念，这对你的学习可能会造成一点影响。
</p>

<p>
如果你找到错误或者不严谨的表述，欢迎你来信告诉我。我的联系方式可以在 <code>About</code> 页面中找到。
</p>
</div>
</div>
<div id="outline-container-org52b4d61" class="outline-2">
<h2 id="org52b4d61">CH.1 Introduction</h2>
<div class="outline-text-2" id="text-org52b4d61">
<p>
这一章没有多少有关Perl技术上的论述。
</p>

<p>
大部分都是对于本书、其作者以及Perl的介绍和几页FAQ，所以在这里跳过。
</p>

<p>
有兴趣的读者可以去阅读原书。
</p>
</div>
</div>
<div id="outline-container-org8a93462" class="outline-2">
<h2 id="org8a93462">CH.2 Scalar Data</h2>
<div class="outline-text-2" id="text-org8a93462">
<p>
当然这里所指的Scalar与数学、物理领域内的Scalar并不相同。Scalar只是对Perl当中一种数据泛类型的称呼。
Scalar通常（大部分情况下）以数字或字符串的形式表现。这里我们可以先将数字与字符串独立审视，就像其他的编程语言那样。
</p>
</div>
<div id="outline-container-orgaf21db0" class="outline-3">
<h3 id="orgaf21db0">Numbers</h3>
<div class="outline-text-3" id="text-orgaf21db0">
<p>
我们可以先看数字这部分。
</p>
</div>
<div id="outline-container-orga71ca40" class="outline-4">
<h4 id="orga71ca40">Decimal Numbers</h4>
<div class="outline-text-4" id="text-orga71ca40">
<p>
在Perl，所有的数字内部都是以相同的格式存在。你可以指定整数或者浮点数，但是在Perl内部都是以双精度浮点数（ <code>double-precision floating-point value</code> ）进行计算的。
所以可以理解为对于Perl不存在整数。所有的“整数”都是以 <code>DPFP</code> 类型进行计算的。
</p>

<p>
所以以下这些数字在Perl都是合法的。
<code>25, 25.5, 25.255, 25.0, 25.000, 25e25, -25e25, -25e-25</code>
</p>

<p>
在Perl中，数字通过下划线标记位数是允许的。
例如：
</p>

<p>
<code>1000000</code> 可以被写为 <code>1_000_000</code> ，这在Perl内部是相同的两个数字。
</p>
</div>
</div>
<div id="outline-container-org03a6f42" class="outline-4">
<h4 id="org03a6f42">Nondecimal Integer</h4>
<div class="outline-text-4" id="text-org03a6f42">
<p>
在编程中，非十进制数字使用最广泛的有：二进制 <code>binary</code> 、八进制 <code>octal</code> 、十六进制 <code>hexademical</code> 。
二进制用 <code>0b</code> 标识，八进制用 <code>0</code> ，十六进制用 <code>0x</code> 。所以以下的数字都是 <b>相同</b> 的。
</p>

<div class="org-src-container">
<pre class="src src-sh">0b1010 012 0xA 10 10.000
</pre>
</div>

<p>
当然，对于非十进制的数字也可以用下划线标记位数，例如 <code>0b10_11_10_00</code> 是合法的。
</p>

<p>
需要注意的是，所谓的 <code>"Leading zero" Indicator</code> 只针对于普通的Literal数据，自动的字符串-&gt;数字变换是不支持的。也就是说你不可以将 <code>"0b11"</code> 这个字符串与 <code>3</code> 等同，但是 <code>0b11</code> 与 <code>"3"</code> 可以。
你可以使用 <code>oct()</code> 与 <code>hex()</code> 函数进行字符串到非十进制数字之间的转换。
</p>
</div>
</div>
<div id="outline-container-org98da00b" class="outline-4">
<h4 id="org98da00b">Numeric Operators</h4>
<div class="outline-text-4" id="text-org98da00b">
<p>
Perl当然支持最普通的四则运算 <code>+ - * /</code> 与模运算 <code>%</code> ，当然也支持浮点数与整数混合运算。
在浮点数进行模运算时，Perl会自动将浮点数取整，所以 <code>15.6 % 2.4</code> 与 <code>15 % 2</code> 结果相同。
</p>

<p>
Perl同时也支持幂运算，例如 <code>2**3</code> 结果为 <code>8</code> 。
</p>

<p>
当你需要计算负数的分数幂的时候，你可以调用 <code>Math::Complex</code> 模块进行复数运算。
</p>

<p>
Perl还有其他一些数字运算符，当我们需要的时候会进行讲解。
</p>
</div>
</div>
</div>
<div id="outline-container-orgfa581f9" class="outline-3">
<h3 id="orgfa581f9">Strings</h3>
<div class="outline-text-3" id="text-orgfa581f9">
<p>
字符串可以理解为串在一起的一堆字符。
</p>
</div>
<div id="outline-container-org342edf8" class="outline-4">
<h4 id="org342edf8">Single and Double Quoted Strings.</h4>
<div class="outline-text-4" id="text-org342edf8">
<p>
原书中有一段话：
</p>
<blockquote>
<p>
This is in accordance with the principle of “no built-in limits” that Perl follows at every opportunity.
</p>
</blockquote>
<p>
所以你既可以在一段字符串中加入可打印的字符，也可以加入不可打印的字符，比如二进制数据，然后对他们进行各种操作。这在Perl内都是合法的。
</p>

<p>
Perl内的字符串有两种表示形式， <code>Single-Quoted String Literals</code> 与 <code>Double-Quoted String Literals</code> 。
</p>

<p>
在单引号字符串中，只支持单引号 <code>'</code> 与反斜杠 <code>\</code> 的字符转义，所以，单引号字符串是最简单最纯粹的字符串表示形式。
</p>

<p>
然而，在双引号字符串中，支持所有的转义字符，换行 <code>\n</code> ,制表符Tab <code>\t</code>,和对ASCII值的引用等。
</p>

<p>
同时，你可以在双引号字符串中插入变量，所以，
</p>

<div class="org-src-container">
<pre class="src src-perl">$<span style="color: #79a8ff;">foo</span> = <span style="color: #00c06f;">"bar"</span>;
print <span style="color: #00c06f;">"$foo is bar"</span>;
</pre>
</div>

<p>
结果会输出 <code>bar is bar</code> 。
</p>
</div>
</div>

<div id="outline-container-orgf5e7087" class="outline-4">
<h4 id="orgf5e7087">String Operators</h4>
<div class="outline-text-4" id="text-orgf5e7087">
<p>
字符串之间可以通过 <code>.</code> 进行连接，对，就是一个点。
所以：
</p>

<div class="org-src-container">
<pre class="src src-perl"><span style="color: #00c06f;">"hello"</span>.<span style="color: #00c06f;">"world"</span> == <span style="color: #00c06f;">"hel"</span>.<span style="color: #00c06f;">"lowo"</span>.<span style="color: #00c06f;">"rld"</span>
</pre>
</div>

<p>
字符串可以用 <code>x</code> 字符进行复制倍增， <code>x</code> 前的Literal会被视为字符或字符串，其后的Literal会被视为数字，所以：
</p>

<div class="org-src-container">
<pre class="src src-perl"><span style="color: #00c06f;">"foo"</span> x 3 == <span style="color: #00c06f;">"foo"</span> x <span style="color: #00c06f;">"3"</span> == <span style="color: #00c06f;">"foofoofoo"</span>
<span style="color: #00c06f;">"5"</span> x <span style="color: #00c06f;">"3"</span> == 5 x <span style="color: #00c06f;">"3"</span> == 5 x 3 == 5 x 3.3 == 5 x <span style="color: #00c06f;">"3.3"</span> == 555
</pre>
</div>
<p>
当倍增的数字小于1时，会输出空字符串 <code>""</code> 。
</p>

<p>
这是关于Perl一个神奇的特性。
</p>
</div>
</div>
<div id="outline-container-org1bf04d9" class="outline-4">
<h4 id="org1bf04d9">Automatic Conversion Between Numbers and Strings</h4>
<div class="outline-text-4" id="text-org1bf04d9">
<p>
关于这部分，原书有很好的诠释:
</p>
<blockquote>
<p>
For the most part, Perl automatically converts between numbers and strings as needed.How does it know which is needed? It all depends upon the operator being used on thescalar value. If an operator expects a number (like + does), Perl will see the value as anumber. If an operator expects a string (like . does), Perl will see the value as a string.So you don’t need to worry about the difference between numbers and strings; just usethe proper operators, and Perl will make it all work.
</p>
</blockquote>

<p>
所以:
</p>

<div class="org-src-container">
<pre class="src src-perl"><span style="color: #00c06f;">"12"</span> * <span style="color: #00c06f;">"3"</span> == 12 * 3 == 36
<span style="color: #00c06f;">"12foo"</span> * <span style="color: #00c06f;">"3bar"</span> == 36
</pre>
</div>

<p>
但是在执行第二条计算的时候，Perl会抛出一个Warning： <code>Argument "3bar" isn't numeric in multiplication (*)</code>
所以可以视为，当一个数字与字母混合的字符串被转换为字符时，Perl会在字符串头部寻识别数字，如果没有则返回0.
</p>
</div>
</div>
</div>

<div id="outline-container-org45f179f" class="outline-3">
<h3 id="org45f179f">Perl's Built-in Warnings</h3>
<div class="outline-text-3" id="text-org45f179f">
<p>
在这里需要插入一个Perl内置警告的单元。
</p>

<p>
如果你要开启Perl的内置警告，可以在运行脚本时使用 <code>-w</code> 参数，或者直接在脚本头部添加 <code>-w</code> 参数，例如
</p>

<div class="org-src-container">
<pre class="src src-sh">$ perl -w some_script
</pre>
</div>

<p>
或者：
</p>

<div class="org-src-container">
<pre class="src src-perl"><span style="color: #a8a8a8;">#</span><span style="color: #a8a8a8;">!/usr/bin/perl -w</span>
</pre>
</div>

<p>
甚至简略为：
</p>

<div class="org-src-container">
<pre class="src src-perl"><span style="color: #a8a8a8;">#</span><span style="color: #a8a8a8;">!perl -w</span>
</pre>
</div>

<p>
在Perl5.6或更新的Perl中，你可以这样写：
</p>

<div class="org-src-container">
<pre class="src src-perl"><span style="color: #a8a8a8;">#</span><span style="color: #a8a8a8;">!/usr/bin/perl</span>
<span style="color: #00d3d0;">use</span> <span style="color: #b6a0ff;">warnings</span>;
</pre>
</div>

<p>
当你需要更长的诊断类描述时，可以这样写：
</p>

<div class="org-src-container">
<pre class="src src-perl"><span style="color: #a8a8a8;">#</span><span style="color: #a8a8a8;">!/usr/bin/perl</span>
<span style="color: #00d3d0;">use</span> <span style="color: #b6a0ff;">diagnostics</span>;
</pre>
</div>

<p>
显然，这样做会使程序运行得更慢一些，当你不需要或者已经编写或Debug完了程序，应该注释掉这一行。
</p>

<p>
但是对于这种Diagnostic有一种优化便是使用 <code>-M</code> 参数，原书对于 <code>-M</code> 参数的诠释是这样的：
</p>
<blockquote>
<p>
A further optimization can be had by using one of Perl’s command-line options, -M, toload the pragma only when needed instead of editing the source code each time toenable and disable diagnostics.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org38f9f7f" class="outline-3">
<h3 id="org38f9f7f">Scalar Variables</h3>
<div class="outline-text-3" id="text-org38f9f7f">
<blockquote>
<p>
A variable is a name for a container that holds one or more values. The name of thevariable stays the same throughout the program, but the value or values contained inthat variable typically change over and over again throughout the execution of theprogram.
</p>
</blockquote>

<p>
所以在Perl中变量的特性与用法在其他编程语言中并没有区别。
</p>

<p>
在Perl中一个scalar variable只能储存一个scalar value,
</p>

<p>
但是Perl中的Scalar Variable需要一个代表变量名的符号，以便与其他Literals区别开来，在这里使用的是美元符号 <code>$</code> 。
在Perl中这类符号称作 <code>Sigil</code> , 对于不同的变量需要不同的Sigil，在后面
变量名（通常使用的表述是 <code>Perl Identifier</code> ）不可以以数字开头，而且大小写区分。
</p>
</div>
</div>
<div id="outline-container-org4ca5b4b" class="outline-3">
<h3 id="org4ca5b4b">Scalar Assignment</h3>
<div class="outline-text-3" id="text-org4ca5b4b">
<p>
对于Scalar Variable的赋值操作，与其他的编程语言大致相似。赋值操作通过 <code>=</code> 来进行，例如：
</p>

<div class="org-src-container">
<pre class="src src-perl">$<span style="color: #79a8ff;">foo</span> = 3;
$<span style="color: #79a8ff;">foo</span> = $<span style="color: #79a8ff;">foo</span> + 3;
$<span style="color: #79a8ff;">foo</span> += 3;
$<span style="color: #79a8ff;">foo</span> = <span style="color: #00c06f;">"bar"</span>;
$<span style="color: #79a8ff;">foo</span> = $<span style="color: #79a8ff;">foo</span> . <span style="color: #00c06f;">"foo"</span>;
$<span style="color: #79a8ff;">foo</span> = $<span style="color: #79a8ff;">foo</span> x 3;
$<span style="color: #79a8ff;">foo</span> x= 3;
$<span style="color: #79a8ff;">foo</span> .= <span style="color: #00c06f;">"foo"</span>;
</pre>
</div>

<p>
类似的操作都是合法的。
</p>
</div>
</div>
<div id="outline-container-org26e754e" class="outline-3">
<h3 id="org26e754e">Output with print</h3>
<div class="outline-text-3" id="text-org26e754e">
<p>
Perl中的 <code>print()</code> 函数与其他语言中的类似，而且可以携带或不携带括号 <code>()</code> 。例如：
</p>

<div class="org-src-container">
<pre class="src src-perl">print <span style="color: #00c06f;">"hello world\n"</span>;    <span style="color: #a8a8a8;"># &#36755;&#20986;&#20026; &#8220;hello world&#8221;&#20197;&#21450;&#19968;&#20010;&#26032;&#34892;&#12290;</span>

print <span style="color: #00c06f;">"the answer is "</span>;
print 2*<span style="color: #79a8ff;">3</span>;
print <span style="color: #00c06f;">".\n"</span>;    <span style="color: #a8a8a8;"># &#36755;&#20986;&#20026;&#8220;the answer is 6.&#8221;&#20197;&#21450;&#19968;&#20010;&#26032;&#34892;&#12290;</span>

<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">&#24403;&#28982;&#20063;&#21487;&#20197;&#36825;&#20040;&#25805;&#20316;&#12290;</span>

print <span style="color: #00c06f;">"the answer is"</span>. 6*<span style="color: #79a8ff;">7</span> .<span style="color: #00c06f;">".\n"</span>;

<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">&#36755;&#20986;&#26159;&#30456;&#21516;&#30340;&#12290;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org158b15f" class="outline-3">
<h3 id="org158b15f">Interpolation of Scalar Variables into Strings</h3>
<div class="outline-text-3" id="text-org158b15f">
<p>
在双引号字符串中引用scalar variable，可以自动替换为该变量的值。例如：
</p>

<div class="org-src-container">
<pre class="src src-perl">$<span style="color: #79a8ff;">foo</span> = <span style="color: #00c06f;">"bar"</span>;
print <span style="color: #00c06f;">"$foo is bar"</span>;
</pre>
</div>

<p>
结果会输出 <code>bar is bar</code> 。
</p>

<p>
在被引用的变量没有被赋值或声明时，会以 <code>""</code> (空字符串)或 <code>0</code> 来代替。
</p>

<p>
<b>注意</b>,这种Interpolation只能在双引号字符串中进行，单引号字符串是没有这种效果的。
</p>

<p>
同时，在这种Interpolation中，Perl会寻找所谓的 <i>Longest Possible Variable</i> ，所以为了避免程序出Bug，你可能想要用一些可用的分割符来进行变量名与字符串之间的分割。
例如：
</p>


<div class="org-src-container">
<pre class="src src-perl">$<span style="color: #79a8ff;">foo</span> = 1;
$<span style="color: #79a8ff;">foobar</span> = 2;
print <span style="color: #00c06f;">"$foos"</span>;        <span style="color: #a8a8a8;">#&#20250;&#36755;&#20986;&#8220;1s&#8221;</span>
print <span style="color: #00c06f;">"$foobar"</span>;      <span style="color: #a8a8a8;">#&#20250;&#36755;&#20986;&#8220;2&#8221;</span>
print <span style="color: #00c06f;">"$foo"</span>.<span style="color: #00c06f;">"bar"</span>;   <span style="color: #a8a8a8;">#&#20250;&#36755;&#20986;&#8220;1bar&#8221;</span>
print <span style="color: #00c06f;">"${foo}bar"</span>;    <span style="color: #a8a8a8;">#&#20250;&#36755;&#20986;&#8220;1bar&#8221;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org0ec277c" class="outline-3">
<h3 id="org0ec277c">Operator Precedence and Associativity</h3>
<div class="outline-text-3" id="text-org0ec277c">
<p>
操作优先级这方面没有什么好讲的，Perl的各种操作优先级（包括二进制位操作）都与C语言相同。
</p>
<blockquote>
<p>
So should you just memorize the precedence chart? No! Nobody actually does that.Instead, just use parentheses when you don’t remember the order of operations, orwhen you’re too busy to look in the chart. After all, if you can’t remember it withoutthe parentheses, your maintenance programmer is going to have the same trouble. Sobe nice to your maintenance programmer: you may be that person one day.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org43b6e67" class="outline-3">
<h3 id="org43b6e67">Comparison Operators</h3>
<div class="outline-text-3" id="text-org43b6e67">
<p>
对于数字之间的比较，Perl有以下几种操作符：
</p>

<div class="org-src-container">
<pre class="src src-perl">&lt; &lt;= == &gt;= !=
</pre>
</div>

<p>
他们进行判断的返回值都是真或假 <code>true / false</code> 。
</p>

<p>
对于字符串之间的比较，Perl有以下集中操作符：
</p>

<div class="org-src-container">
<pre class="src src-perl">lt le eq ge gt ne
</pre>
</div>

<p>
分别代表 <code>less than , less or equal , equal , greater or equal , greater than , not equal</code> 。
</p>

<p>
Perl中字符串的比较方法是从头至为比较单个字符的ASCII值，而且需要注意的是在ASCII码表中大写字母在小写字母前面，所以表达式 <code>"Ab" lt "ab"</code> 返回 <code>true</code> 。
</p>
</div>
</div>

<div id="outline-container-orgd0b64e1" class="outline-3">
<h3 id="orgd0b64e1">The if Control Structure</h3>
<div class="outline-text-3" id="text-orgd0b64e1">
<p>
又到了喜闻乐见的条件选择环节。
</p>

<p>
在Perl中， <code>if</code> 结构与C语言大致相同，例如：
</p>

<div class="org-src-container">
<pre class="src src-perl"><span style="color: #00d3d0;">if</span> (&lt;<span style="color: #b6a0ff;">condition</span>&gt;){
    <span style="color: #a8a8a8;"># do something;</span>
}  <span style="color: #00d3d0;">elsif</span> (&lt;<span style="color: #b6a0ff;">condition</span>&gt;) {
    <span style="color: #a8a8a8;"># do another something;</span>
}  <span style="color: #00d3d0;">else</span> {
    <span style="color: #a8a8a8;"># ok let's do this;</span>
}
</pre>
</div>

<p>
在Perl的if语句中，括号是必须的。
</p>

<p>
Condition 返回的可以为True or False，当Condition为一个数字，除0外所有数字均为 <code>True</code> ，当Condition为一个字符串，除了空字符串 <code>''</code> 以外所有字符串均为真，否则（该Scalar Data为除字符串或数字以外的值）将该值转换为数字或字符串然后在进行判断。
</p>

<p>
而且这里有一个little trick：在Perl中字符 <code>'0'</code> 与数字 <code>0</code> 是可互相转化的，所以 <code>'0'</code> 是Perl中唯一可以被判断为假的非空字符串。
</p>
</div>
</div>

<div id="outline-container-orgb6f4246" class="outline-3">
<h3 id="orgb6f4246">Getting User Input</h3>
<div class="outline-text-3" id="text-orgb6f4246">
<p>
在Perl中获取输入有一种很简单的方式， <code>&lt;STDIN&gt;</code> ，例如：
</p>

<div class="org-src-container">
<pre class="src src-perl">$<span style="color: #79a8ff;">foo</span> = &lt;<span style="color: #b6a0ff;">STDIN</span>&gt;;
</pre>
</div>

<p>
需要注意的是，&lt;STDIN&gt;返回的是一串字符串，以换行符做结尾，所以&lt;STDIN&gt;的返回值不可能是空字符串，最短返回值为 <code>'\n'</code> 。
</p>

<p>
但是在大部分情况下并不需要这个结尾的换行符，所以我们需要另一个函数去去除输入时的换行符。
</p>
</div>
</div>
<div id="outline-container-orgfbb72e1" class="outline-3">
<h3 id="orgfbb72e1">The chomp Operator</h3>
<div class="outline-text-3" id="text-orgfbb72e1">
<p>
<code>chomp()</code> 的使用方法类似这样：
</p>

<div class="org-src-container">
<pre class="src src-perl">$<span style="color: #79a8ff;">foo</span> = &lt;<span style="color: #b6a0ff;">STDIN</span>&gt;;
chomp($<span style="color: #79a8ff;">foo</span>);    <span style="color: #a8a8a8;"># &#36825;&#37324;&#30340;&#25324;&#21495;&#26159;&#21487;&#20197;&#30465;&#30053;&#30340;&#12290;</span>
</pre>
</div>

<p>
或者再短一点：
</p>

<div class="org-src-container">
<pre class="src src-perl">chomp($<span style="color: #79a8ff;">foo</span>=&lt;<span style="color: #b6a0ff;">STDIN</span>&gt;);    <span style="color: #a8a8a8;">#&#36825;&#37324;&#30340;&#25324;&#21495;&#19981;&#21487;&#20197;&#30465;&#30053;&#12290;</span>
</pre>
</div>

<p>
作为一个函数， <code>chomp()</code> 是有返回值的，它会返回去除的字符的数量————通常情况下这个数字为1,因为在有多个换行符作为末尾的情况下， <code>chomp()</code> 也只会移除一个。但是当输入为空字符串或无末尾换行符的字符串， <code>chomp()</code> 会返回0。
</p>
</div>
</div>

<div id="outline-container-org3c93488" class="outline-3">
<h3 id="org3c93488">The while Control Structure</h3>
<div class="outline-text-3" id="text-org3c93488">
<p>
又是一个十分常用的结构。同样，Perl的while语句也和C类似：
</p>

<div class="org-src-container">
<pre class="src src-perl"><span style="color: #00d3d0;">while</span>(&lt;<span style="color: #b6a0ff;">condition</span>&gt;){
    <span style="color: #a8a8a8;"># do something;</span>
}
</pre>
</div>

<p>
<code>condition</code> 的判断方式已经介绍过，这里不再赘述。
</p>
</div>
</div>

<div id="outline-container-orgd627683" class="outline-3">
<h3 id="orgd627683">The undel Value</h3>
<div class="outline-text-3" id="text-orgd627683">
<p>
Perl的一个很有趣的特性便是这个 <code>undef</code> 值，它适用于引用未声明或赋值的变量时，可以被自动转换为 <code>0</code> 或 <code>''</code> ，所以：
</p>

<div class="org-src-container">
<pre class="src src-perl">$<span style="color: #79a8ff;">unassigned_variable</span> = <span style="color: #00c06f;">"foo"</span>;

$<span style="color: #79a8ff;">another_unassigned_variable</span> .= <span style="color: #00c06f;">"foo"</span>;
</pre>
</div>

<p>
两者是相等的。
</p>

<p>
原书中写道：
</p>
<blockquote>
<p>
<i>Many operators return undef when the arguments are out of range or don’t make sense&#x2026;. But you should know that when warnings are turned on, Perl willtypically warn about unusual uses of the undefined value, since that may indicate abug. For example, simply copying undef from one variable into another isn’t a problem,but trying to print it would generally cause a warning.</i>
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org7cc8a25" class="outline-3">
<h3 id="org7cc8a25">The defined Function</h3>
<div class="outline-text-3" id="text-org7cc8a25">
<p>
<code>&lt;STDIN&gt;</code> 操作通常会返回一个字符串，但是也有特例。当你在扫描一个文件时，如果遇到 <code>EOF</code> ，那么 <code>&lt;STDIN&gt;</code> 会返回 <code>undef</code> ，这时你可以用 <code>defined()</code> 函数来判断某个变量是否被赋值。
<code>defined()</code> 当输入的值为 <code>undef</code> 时返回假，其他情况均返回真。
</p>

<p>
当然，你也可以为某个变量赋值 <code>undef</code> ，虽然这与没声明该变量没有什么区别，但是某些情况下这个特性是很有用的。
</p>
</div>
</div>
</div>

<div id="outline-container-org280b32c" class="outline-2">
<h2 id="org280b32c">CH.3 List and Arrays</h2>
<div class="outline-text-2" id="text-org280b32c">
<p>
首先我觉得需要澄清一下的是，在Perl社区中，List和Array其实通常可以互相代换。
但是严格意义上来说，List是一些Scalar Data按照一定的顺序排列在一起组成的数据结构，而Array是指向某个List的变量。
例如：
</p>

<div class="org-src-container">
<pre class="src src-perl">@<span style="color: #79a8ff; text-decoration: underline;">an_array</span> = qw<span style="color: #00c06f;">[this that foo bar]</span>;    <span style="color: #a8a8a8;">#&#36825;&#26159;&#19968;&#20010;&#25968;&#21015;</span>
print $<span style="color: #79a8ff;">an_array</span>[1];                   <span style="color: #a8a8a8;">#&#36755;&#20986; "that"</span>
</pre>
</div>

<p>
两者之间并没有一个十分严格的界限，所以书中也写道：
</p>

<blockquote>
<p>
A list is an ordered collection of scalars. An array is a variable that contains a list. In Perl, the two terms are often used as if they’re interchangeable. But, to be accurate, the list is the data, and the array is the variable.
</p>
</blockquote>
</div>

<div id="outline-container-org7bdb91a" class="outline-3">
<h3 id="org7bdb91a">List</h3>
<div class="outline-text-3" id="text-org7bdb91a">
<p>
列表中的每一个元素都是一个 <code>Scalar Variable</code> 而且拥有一个 <code>Scalar value</code>, 这些变量是有一定顺序的，而且从零开始计数。
列表中的元素不一定要是同一种类型，数字，字符串， <code>undef</code> 都是可以放到同一个列表中的。
Perl不对列表的大小做限制，只要你的内存是足够的，你可以创建一个任意大的列表。所以最小的列表就是那些没有任何元素的列表。
</p>
</div>
</div>
<div id="outline-container-orgd85d374" class="outline-3">
<h3 id="orgd85d374">调用数列中的元素</h3>
<div class="outline-text-3" id="text-orgd85d374">
<p>
Perl调用数列元素的方式也很简单，例如：
</p>

<div class="org-src-container">
<pre class="src src-perl">$<span style="color: #79a8ff;">foo</span>[0]=<span style="color: #00c06f;">"foo"</span>;
$<span style="color: #79a8ff;">foo</span>[1]=<span style="color: #00c06f;">"bar"</span>;
print $<span style="color: #79a8ff;">foo</span>[1];    <span style="color: #a8a8a8;">#&#36755;&#20986; "bar"</span>
</pre>
</div>

<p>
在Perl当中， <code>Array</code> 和 <code>Scalar Variable</code> 使用的是两种不同的命名域，所以你可以使某个变量和数列使用同一个名字。
例如：
</p>

<div class="org-src-container">
<pre class="src src-perl">$<span style="color: #79a8ff;">foo</span>=<span style="color: #00c06f;">"foo"</span>;
$<span style="color: #79a8ff;">foo</span>[0]=<span style="color: #00c06f;">"bar"</span>;
print $<span style="color: #79a8ff;">foo</span>.$<span style="color: #79a8ff;">foo</span>[0];    <span style="color: #a8a8a8;">#&#32467;&#26524;&#20250;&#36755;&#20986; "foobar"</span>
</pre>
</div>

<p>
但是为了你的代码的可维护性，没人会建议你这么做。
</p>

<p>
在调用数列元素的时候，你也可以在 <code>index</code> 的位置输入字符串或者浮点数或者是其他变量，Perl会自动转换为对应的整数。
例如：
</p>

<div class="org-src-container">
<pre class="src src-perl">$<span style="color: #79a8ff;">foo</span>[0]=<span style="color: #00c06f;">"foo"</span>;
$<span style="color: #79a8ff;">foo</span>[1]=<span style="color: #00c06f;">"bar"</span>;
$<span style="color: #79a8ff;">the_number</span>=1.618
print $<span style="color: #79a8ff;">foo</span>[$<span style="color: #79a8ff;">the_number</span>-1].$<span style="color: #79a8ff;">foo</span>[<span style="color: #00c06f;">"1H4T3SCH00L"</span>]    <span style="color: #a8a8a8;">#&#32467;&#26524;&#20250;&#36755;&#20986; "foobar"</span>
</pre>
</div>

<p>
当调用超出数列元素数的元素时，Perl会返回 <code>undef</code> .
例如：
</p>

<div class="org-src-container">
<pre class="src src-perl">$<span style="color: #79a8ff;">foo</span>[0]=0;
$<span style="color: #79a8ff;">foo</span>[1]=1;
<span style="color: #00d3d0;">if</span>(!defined($<span style="color: #79a8ff;">foo</span>[99])){
    print <span style="color: #00c06f;">"Not defined!"</span>;}    <span style="color: #a8a8a8;">#&#32467;&#26524;&#20250;&#36755;&#20986; "Not defined!"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbf864da" class="outline-3">
<h3 id="orgbf864da">Special Array Indices</h3>
<div class="outline-text-3" id="text-orgbf864da">
<p>
在Perl中，当你给一个超出数列范围的元素赋值时，数列会自动扩张到合适的大小并给对应的元素赋值，而且新增加的元素会被赋值为 <code>undef</code> 。例如：
</p>

<div class="org-src-container">
<pre class="src src-perl">$<span style="color: #79a8ff;">foo</span>[0]=<span style="color: #00c06f;">"foo"</span>;
$<span style="color: #79a8ff;">foo</span>[1]=<span style="color: #00c06f;">"bar"</span>;
$<span style="color: #79a8ff;">foo</span>[99]=<span style="color: #00c06f;">"well that was quite a gap!"</span>;
<span style="color: #a8a8a8;"># </span><span style="color: #a8a8a8;">&#20174; $foo[2] &#21040; $foo[98] &#20043;&#38388;&#30340;&#20803;&#32032;&#22343;&#20026; undef</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Ilghar Kus</p>
<p class="date">Created: 2022-11-19 Sat 03:21</p>
</div>
</body>
</html>
